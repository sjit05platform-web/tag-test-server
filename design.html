
<!DOCTYPE html>
<html lang="ko">
<head>
  <!-- ▼▼▼ 보호 페이지 공통: <head> 맨 위에 넣기 ▼▼▼ -->
  <meta charset="UTF-8" />
  <style>
    html.auth-check { visibility: hidden }
  </style>

  <script>
    // UI 깜빡임 방지: 인증 끝날 때까지 숨김
    document.documentElement.classList.add('auth-check');

    // 로그인 페이지 경로 (필요시 상대경로 조정)
    window.__LOGIN_PAGE__ = 'login.html';

    // Cognito User Pool 설정
    window.__POOL__ = {
      UserPoolId: 'ap-northeast-2_jubP19tft', // ← 실제 값
      ClientId:   '2mpr21p7900br0n3p03g8f9ota', // ← 실제 값
    };
  </script>

  <!-- Cognito SDK들 (순서 중요) -->
  <script src="aws-cognito-sdk.min.js"></script>
  <script src="amazon-cognito-identity.min.js"></script>

  <!-- 인증 가드 -->
  <script>
    (function authGuard() {
      function goLogin() {
        const u = new URL(window.__LOGIN_PAGE__, location.href);
        u.searchParams.set('redirect', location.href); // 로그인 후 돌아올 곳
        location.replace(u.toString());
      }

      (function waitLib(){
        if (!window.AmazonCognitoIdentity){ return setTimeout(waitLib, 20); }
        try{
          const pool = new AmazonCognitoIdentity.CognitoUserPool(window.__POOL__);

          // 🔸 브라우저 세션 플래그가 없으면 강제 재로그인
          if (!sessionStorage.getItem('app_session')) {
            const u = pool.getCurrentUser();
            if (u) { try { u.signOut(); } catch(e){} }
            return goLogin();
          }

          const user = pool.getCurrentUser();
          if (!user) return goLogin();

          user.getSession(function(err, session){
            if (err || !session || !session.isValid()) return goLogin();

            try {
              const groups = (session.getIdToken().payload || {})['cognito:groups'] || [];
              sessionStorage.setItem('app_is_admin', groups.includes('admin') ? '1' : '0');
            } catch {}

            // 페이지 표시
            document.documentElement.classList.remove('auth-check');

            // ✅ 이메일 저장 + 즉시 표시 시도(요소가 있으면만)
            user.getUserAttributes(function(e, attrs){
              let email = (typeof user.getUsername === 'function') ? user.getUsername() : '';
              if (!e && Array.isArray(attrs)) {
                const em = attrs.find(a => (a.getName && a.getName() === 'email') || a?.Name === 'email');
                if (em) email = (em.getValue ? em.getValue() : em.Value);
              }
              try { sessionStorage.setItem('app_user_email', email); } catch {}
              const box  = document.getElementById('sidebar-greet');
              const name = document.getElementById('sidebar-greet-name');
              if (box && name) { name.textContent = email || ''; box.classList.remove('hidden'); }
            });
          });
        }catch(e){ goLogin(); }
      })();
    })();
  </script>
  <!-- ▲▲▲ 여기까지가 '무조건 로그인 먼저' 가드 ▲▲▲ -->

  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tag Monitor</title>

  <!-- 아이콘/폰트/유틸 -->
  <link rel="shortcut icon" href="https://example-s3-3.s3.ap-northeast-2.amazonaws.com/images.PNG" type="image/x-icon" sizes="16x16">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css">

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com/3.4.16"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: { primary:'#1E88E5', secondary:'#F5F6FA' },
          borderRadius: {
            'none':'0px','sm':'4px', DEFAULT:'8px','md':'12px','lg':'16px',
            'xl':'20px','2xl':'24px','3xl':'32px','full':'9999px','button':'8px'
          }
        }
      }
    }
  </script>

  <!-- ECharts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"></script>

  <!-- ★ 공통 UI CSS -->
  <link rel="stylesheet" href="./ui-common.css" />

  <style>
    body{font-family:'Noto Sans KR',sans-serif;background:#f8fafc}
    .mono{font-family:'Roboto Mono',monospace}
  </style>

  <style>
  /* 전광판 페이드인 */
  #hdr-rotator{ position:relative; min-height:24px; }
  #hdr-rotator .rot-line{
    position:absolute; inset:0;
    opacity:0; transform:translateY(8px);
    transition:opacity .4s ease, transform .4s ease;
    will-change:opacity,transform;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }
  #hdr-rotator .rot-line.show{
    opacity:1; transform:translateY(0);
  }
</style>

</head>

<body>
  <!-- ★ 공통 레이아웃(sj-shell) + 사이드바/메인 -->
  <div class="sj-shell">
    <!-- 공통 사이드바: 자동 렌더 -->
    <aside class="sj-sidebar" data-sj-sidebar></aside>

    <!-- 메인 -->
    <main class="sj-main">
      <!-- 공통형 헤더 -->
      <header class="sj-header">
        <div class="sj-title text-sm">
          
        </div>

        <!-- ★ 전광판(공통 로테이터) -->
        <div data-sj-rotator id="hdr-rotator" class="w-[240px] sm:w-[320px] md:w-[480px]"></div>
      </header>

      <!-- 페이지 콘텐츠 -->
      <section class="p-6">
        <div class="mb-6">
          <h2 class="text-xl font-bold text-gray-800">실시간 대시보드</h2>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8" id="realtime-panel">
          <!-- 디바이스 목록 -->
          <div class="bg-white rounded-lg shadow-sm p-6">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-base font-medium text-gray-800">디바이스 목록 (tag_address)</h3>
              <span id="rt-count" class="text-xs text-gray-500"></span>
            </div>
            <div id="rt-device-list" class="space-y-2 h-80 overflow-y-auto"></div>
          </div>

          <!-- 상세 카드 3열 (온도 / 배터리 / 에러·전송) -->
          <div class="lg:col-span-2 grid grid-cols-1 md:grid-cols-3 gap-6">
            <!-- 온도 -->
            <div class="bg-white rounded-lg shadow-sm p-4">
              <div class="text-xs text-gray-600" id="rt-tempLabel">온도 데이터 : —</div>
              <div class="text-xl font-bold mt-1" id="rt-tempState">—</div>
            </div>
            <!-- 배터리 -->
            <div class="bg-white rounded-lg shadow-sm p-4">
              <div class="text-xs text-gray-600" id="rt-battLabel">배터리 : —</div>
              <div class="text-xl font-bold mt-1" id="rt-battState">—</div>
            </div>
            <!-- 에러/전송 상태 -->
            <div class="bg-white rounded-lg shadow-sm p-4">
              <div class="text-xs text-gray-600">에러/전송 상태</div>
              <div class="mt-2 flex items-center gap-2">
                <span id="rt-errorState" class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-700">—</span>
                <span class="text-xs text-gray-400">코드: <span id="rt-errorCode" class="mono font-medium">—</span></span>
              </div>
              <div class="text-xs text-gray-600 mt-2">전송 유형: <span id="rt-sendType" class="mono font-medium">—</span></div>
            </div>

            <!-- 위치 -->
            <div class="bg-white rounded-lg shadow-sm p-6 md:col-span-2">
              <div class="text-sm text-gray-600">위치</div>
              <div class="text-xl mt-2 font-mono" id="rt-location">—</div>
              <button id="open-map" class="mt-4 px-3 py-2 text-sm text-white bg-primary rounded-lg disabled:opacity-50" disabled>지도에서 보기</button>
            </div>
            <!-- 마지막 갱신 -->
            <div class="bg-white rounded-lg shadow-sm p-6">
              <div class="text-sm text-gray-600">마지막 갱신</div>
              <div class="text-xl mt-2" id="rt-last">—</div>
            </div>
          </div>
        </div>

        <!-- 실시간 차트 -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8" id="rt-charts">
          <div class="bg-white rounded-lg shadow-sm p-6">
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-base font-medium text-gray-800">온도 추이</h3>
              <span class="text-xs text-gray-500">실시간</span>
            </div>
            <div id="rt-temp-chart" class="w-full h-64"></div>
          </div>
          <div class="bg-white rounded-lg shadow-sm p-6">
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-base font-medium text-gray-800">배터리 전압 추이</h3>
              <span class="text-xs text-gray-500">실시간</span>
            </div>
            <div id="rt-batt-chart" class="w-full h-64"></div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- (선택) 알람 캡처 로직 유지 -->
  <script src="alarm-capture.js"></script>

  <!-- ★ 공통 UI JS (autoInit로 사이드바/로테이터 자동 바인딩) -->
  <script type="module" src="./ui-common.js"></script>
  <script type="module">
    import {
      buildTickerTextsFromDevices,
      publishAlerts,
      subscribeTickerFromOthers,
      macPretty
    } from './ticker-common.js';

    // 모든 페이지에서 1회
    subscribeTickerFromOthers();

    // 페이지 데이터로 전광판 문구 만들고 발행
    function updateTicker() {
      const texts = buildTickerTextsFromDevices({
        devicesMap: window.devices ?? new Map(), // 또는 tags Map 등
        ids:        window.knownIds ?? [],       // 또는 허용 태그 배열
        activeMs:   60_000,
        // labeler: (id) => macPretty(id), // 기본값이 이미 콜론 포함
      });

      // 동시에 여러 건이 있어도 1.2초 간격으로 흘러감(+중복/겹침 방지)
      publishAlerts(
        texts.map(t => ({ text: t, level: 'info' })), // 문자열/객체 모두 OK
        { mode:'replace', staggerMs:1200, broadcast:true }
      );
    }

    // 전역 노출(기존 코드 호환)
    window.updateTicker = updateTicker;

    // 초기/주기 호출(원하는 주기로)
    updateTicker();
    window.__tickerTimer ||= setInterval(updateTicker, 5000);
  </script>

  <!-- ★ 페이지 전용 스크립트 -->
  <script>
    // ===== 공통 사이드바 항목 구성 =====
    window.__SJ_SIDEBAR__ = {
      logo: { text: 'Tag Monitor', href: 'design.html', iconSrc: '', version: 'v0.1' },
      search: false,
      sections: [
        { title: 'Main', items: [
          { icon: 'ri-time-line',        label: '실시간 대시보드', href: 'design.html',  activeMatch: 'design.html' },
          { icon: 'ri-device-line',      label: '디바이스 상세',   href: 'detail.html',  activeMatch: 'detail.html' },
          { icon: 'ri-price-tag-3-line', label: '태그',            href: 'tag.html',     activeMatch: 'tag.html' },
          { icon: 'ri-rfid-line',        label: '게이트웨이',      href: 'gateway.html', activeMatch: 'gateway.html' },
          { icon: 'ri-alarm-warning-line',label:'알람',            href: 'alarm.html',   activeMatch: 'alarm.html' },
          { icon: 'ri-settings-3-line',  label: '설정',            href: 'setting.html', activeMatch: 'setting.html' }
        ] }
      ],
      initiallyOpen: false
    };
  </script>

  

  <!-- ===== 실시간/REST/WS/차트/로테이터(공통화 버전) ===== -->
  <script>
    // ===== 설정 =====
    const WS_URL = "wss://fskxd58gc3.execute-api.ap-northeast-2.amazonaws.com/dev";
    const API_BASE = "https://v9dhc7n563.execute-api.ap-northeast-2.amazonaws.com/dev";
    const ALLOWED_API = "https://ujoxjrept3.execute-api.ap-northeast-2.amazonaws.com/dev/example-user-ble-tag/allowed";
    const COLLECTION_PATH = "calculated_locations";
    const WINDOW_MS = 5 * 60 * 1000;
    const ACTIVE_MS = 60 * 1000;
    const BACKFILL_MIN = 5;
    const SKY = '#87CEFA';
    const SKY_AREA_TOP = 'rgba(135,206,250,0.35)';
    const SKY_AREA_BOTTOM = 'rgba(135,206,250,0.06)';
    const GAP_MS = 20 * 1000;

    // ===== 태그별 온도/배터리 임계값 (공통) =====
    const TH_NS   = 'temp_th_by_tag_v1';    // detail.html과 동일 네임스페이스
    const ABS_MIN = -40, ABS_MAX = 85;      // 센서 허용범위
    const DEF_LOW = 0,   DEF_HIGH = 35;     // 기본 정상구간

    const BATT_NS = 'batt_th_by_tag_v1';
    const BATT_DEF_MIN_PCT = 20; // 기본: 20% 미만이면 '충전 필요'

    // macHex12 폴백(이미 정의돼 있으면 유지)
    if (typeof window.macHex12 !== 'function') {
      window.macHex12 = function(raw){
        const s = String(raw||'').trim();
        const noSep = s.replace(/[:\-\.]/g, '');
        return /^[0-9A-Fa-f]{12}$/.test(noSep) ? noSep.toUpperCase() : null;
      };
    }

    function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
    function _readAll(){ try{ return JSON.parse(localStorage.getItem(TH_NS)||'{}'); }catch{ return {}; } }
    function _writeAll(obj){ localStorage.setItem(TH_NS, JSON.stringify(obj)); }

    /** tagId 기준 임계값 로드(없으면 0~35) */
    function getTempThresholdFor(tagId){
      const key = window.macHex12(tagId);
      const all = _readAll();
      const th  = (key && all[key]) ? all[key] : { low:DEF_LOW, high:DEF_HIGH };
      let low  = Number(th.low),  high = Number(th.high);
      if (!Number.isFinite(low))  low  = DEF_LOW;
      if (!Number.isFinite(high)) high = DEF_HIGH;
      low  = clamp(Math.round(low),  ABS_MIN, ABS_MAX);
      high = clamp(Math.round(high), ABS_MIN, ABS_MAX);
      if (low > high){ const t=low; low=high; high=t; }
      return { low, high };
    }

    /** tagId 임계값 저장(디자인 페이지에선 보통 안씀, 호환용) */
    function setTempThresholdFor(tagId, low, high){
      const key = window.macHex12(tagId);
      if (!key) return;
      low  = clamp(Math.round(low),  ABS_MIN, ABS_MAX);
      high = clamp(Math.round(high), ABS_MIN, ABS_MAX);
      if (low > high){ const t=low; low=high; high=t; }
      const all = _readAll(); all[key] = { low, high }; _writeAll(all);
      window.dispatchEvent(new CustomEvent('sj:temp-threshold-changed', { detail:{ id:key, low, high } }));
    }

    // 다른 모듈에서 쓰기 좋게 노출
    window.getTempThresholdFor = getTempThresholdFor;
    window.setTempThresholdFor = setTempThresholdFor;

    // detail.html에서 브로드캐스트되면 재렌더
    window.addEventListener('sj:temp-threshold-changed', (e)=>{
      // 선택된 디바이스에 해당하는 변경이면 바로 반영
      const changedId = e?.detail?.id || null;
      if (!changedId || (selected && changedId === selected)) {
        if (typeof renderDetail === 'function' && selected) renderDetail(selected);
      }
    });
    // 다른 탭에서 localStorage 바뀐 경우에도 반영
    window.addEventListener('storage', (e)=>{
      if (e.key === TH_NS) {
        if (typeof renderDetail === 'function' && selected) renderDetail(selected);
      }
    });

    // 전압→% 변환(선형): 0V=0%, 3.3V=100%  (mV로 오면 자동 V로 보정)
    function battVoltageToPercent(v){
      if (v == null || !Number.isFinite(Number(v))) return null;
      let vv = Number(v);
      if (vv > 20) vv = vv / 1000; // mV → V
      const Vmin = 0, Vmax = 3.3;
      let pct = (vv - Vmin) / (Vmax - Vmin) * 100;
      if (!Number.isFinite(pct)) return null;
      return Math.round(Math.max(0, Math.min(100, pct)));
    }

    function _battReadAll(){ try{ return JSON.parse(localStorage.getItem(BATT_NS)||'{}'); }catch{ return {}; } }
    function _battWriteAll(obj){ localStorage.setItem(BATT_NS, JSON.stringify(obj)); }

    function getBattThresholdFor(tagId){
      const key = window.macHex12(tagId);
      const all = _battReadAll();
      const th  = (key && all[key]) ? all[key] : { minPct:BATT_DEF_MIN_PCT };
      let minPct = Number(th.minPct);
      if (!Number.isFinite(minPct)) minPct = BATT_DEF_MIN_PCT;
      minPct = Math.min(100, Math.max(0, Math.round(minPct)));
      return { minPct };
    }

    function setBattThresholdFor(tagId, minPct){
      const key = window.macHex12(tagId);
      if (!key) return;
      minPct = Math.min(100, Math.max(0, Math.round(Number(minPct)||BATT_DEF_MIN_PCT)));
      const all = _battReadAll(); all[key] = { minPct }; _battWriteAll(all);
      window.dispatchEvent(new CustomEvent('sj:batt-threshold-changed', { detail:{ id:key, minPct } }));
    }

    // 값만 넣어도 쓰기 쉬운 상태 계산(라벨/퍼센트/충전필요)
    function stateOfBattByPct(vVolt, tagId){
      const pct = battVoltageToPercent(vVolt);
      if (pct==null) return { label:'—', pct:null, need:null };
      const { minPct } = getBattThresholdFor(tagId);
      const need = pct < minPct;
      return { label: need ? '충전 필요' : '정상', pct, need };
    }

    // 전역 노출
    window.getBattThresholdFor = getBattThresholdFor;
    window.setBattThresholdFor = setBattThresholdFor;
    window.battVoltageToPercent = battVoltageToPercent;

    // detail.html 등에서의 변경 브로드캐스트/스토리지 변경을 받아 재렌더
    window.addEventListener('sj:batt-threshold-changed', (e)=>{
      const changedId = e?.detail?.id || null;
      if (!changedId || (selected && changedId === selected)) {
        if (typeof renderDetail === 'function' && selected) renderDetail(selected);
      }
    });
    window.addEventListener('storage', (e)=>{
      if (e.key === BATT_NS) {
        if (typeof renderDetail === 'function' && selected) renderDetail(selected);
      }
    });

    // 구분자 제거 후 12자리 16진수인지 엄격 검사
    function macHex12(raw){
      const s = String(raw||'').trim();
      const noSep = s.replace(/[:\-\.]/g, ''); // 구분자만 제거
      if (!/^[0-9A-Fa-f]{12}$/.test(noSep)) return null;
      return noSep.toUpperCase();
    }

    // 표시용: 12자리면 콜론 포맷, 아니면 원본 그대로
    function macPretty(raw){
      const h = macHex12(raw);
      if (h) return h.match(/.{2}/g).join(':');
      return String(raw||'');
    }

    const IS_ADMIN = (()=>{ try { return sessionStorage.getItem('app_is_admin') === '1'; } catch { return false; } })();
    let __ALLOWED_TAG_IDS = [];
    let __OWNER_OF = new Map();
    let __ALLOWED_READY = false;

    const normId = s => String(s || '').toUpperCase().trim();

    function currentEmail(){ try { return sessionStorage.getItem('app_user_email') || ''; } catch { return ''; } }
    async function getIdToken(){
      return new Promise(resolve=>{
        try{
          const pool = new AmazonCognitoIdentity.CognitoUserPool(window.__POOL__);
          const u = pool.getCurrentUser();
          if (!u) return resolve('');
          u.getSession((err,s)=>{ if(err||!s||!s.isValid()) return resolve(''); resolve(s.getIdToken().getJwtToken());});
        }catch{ resolve(''); }
      });
    }

    async function fetchAllowedTagIdsFromServer(scope = (IS_ADMIN ? 'all' : 'descendants'), includeOwner = true){
      const me = currentEmail();
      if (!me) return [];
      const token = await getIdToken();

      const url = new URL(ALLOWED_API);
      url.searchParams.set('user_id', me);
      url.searchParams.set('scope', scope);
      if (includeOwner) url.searchParams.set('include_owner', '1');

      try{
        const res = await fetch(url.toString(), {
          method:'GET',
          headers: token ? { 'Authorization': `Bearer ${token}` } : {},
          mode:'cors'
        });
        const data = await res.json().catch(()=> ({}));
        if (!res.ok || !data || !Array.isArray(data.tags)) return [];

        __OWNER_OF = new Map();
        const ids = [];
        for (const t of data.tags){
          let idRaw = (typeof t === 'string') ? t : (t && (t.tag_mac || t.id));
          const id = macHex12(idRaw);
          if (id) {
            ids.push(id);
            if (t && t.ownerId) __OWNER_OF.set(id, String(t.ownerId));
          } else {
            console.warn('[allowed] invalid mac skipped:', idRaw);
          }
        }
        return [...new Set(ids)];
      }catch(e){
        console.error('[allowed] fetch error:', e);
        return [];
      }
    }

    async function refreshAllowedIds(){
      const next = await fetchAllowedTagIdsFromServer(IS_ADMIN ? 'all' : 'descendants', true);
      __ALLOWED_TAG_IDS = next;
      __ALLOWED_READY = true;

      // ▣ 다른 탭/모듈이 참조할 수 있게 window에 노출
      window.__ALLOWED_TAG_IDS = [...__ALLOWED_TAG_IDS];  // 12HEX 배열
      window.__ALLOWED_READY   = true;

      // ▣ 허용목록 기준으로 상태/시계열/knownIds 정리(삭제된 태그 잔상 제거)
      const allow = new Set(__ALLOWED_TAG_IDS);
      for (const k of Array.from(devices.keys())) if (!allow.has(k)) devices.delete(k);
      for (const k of Array.from(series.keys()))  if (!allow.has(k))  series.delete(k);

      // ▣ 전광판이 쓰는 ids 동기화
      knownIds = __ALLOWED_TAG_IDS.slice();
      window.knownIds = knownIds;

      // 선택된 디바이스가 빠졌다면 선택 해제
      if (selected && !allow.has(selected)) { selected = null; saveSelected(); }

      // 화면/전광판 즉시 반영
      renderList();
      if (selected) renderDetail(selected);
      window.SJUI?.TickerHub?.refreshFilter?.(); // 필터 재적용
      window.updateTicker && window.updateTicker();
    }

    async function waitAuthReady(timeoutMs=8000){
      const start = Date.now();
      while (Date.now() - start < timeoutMs){
        const email = currentEmail();
        if (email){
          const t = await getIdToken();
          if (t) return true;
        }
        await new Promise(r=>setTimeout(r,150));
      }
      console.warn('[auth] waitAuthReady timeout; continue without token');
      return false;
    }

    // ===== 전역 유틸(숫자/타임스탬프) =====
    const toNum = (v) => (v==null ? null : (Number.isFinite(Number(v)) ? Number(v) : null));
    function pickTs(x){
      let t = toNum(x?.timestamp ?? x?.ts ?? x?.timestamp_epoch ?? x?.raw_time ?? x?.time);
      if (t==null) return null;
      return (t < 1e12) ? t*1000 : t;  // 초단위면 ms로 보정
    }

    // ===== DOM =====
    const $list = document.getElementById('rt-device-list');
    const $count = document.getElementById('rt-count');
    const $tempLabel = document.getElementById('rt-tempLabel');
    const $tempState = document.getElementById('rt-tempState');
    const $battLabel = document.getElementById('rt-battLabel');
    const $battState = document.getElementById('rt-battState');
    const $location  = document.getElementById('rt-location');
    const $lastSeen  = document.getElementById('rt-last');
    const $openMap   = document.getElementById('open-map');
    const $errorCode = document.getElementById('rt-errorCode');
    const $sendType  = document.getElementById('rt-sendType');
    const $errorState = document.getElementById('rt-errorState');

    // ===== 상태 =====
    const devices = new Map();
    const series  = new Map();
    let knownIds = [];
    let selected  = null;

    // 전역 노출(전광판 모듈에서 사용)
    window.devices  = devices;
    window.knownIds = knownIds;

    // ===== 로컬스토리지(선택) =====
    const PREF_KEY = 'ble_rt_pref_v1';
    const saveSelected = ()=> { try{ localStorage.setItem(PREF_KEY, JSON.stringify({selected})); }catch{} };
    const restoreSelected = ()=> {
      try{
        const raw = localStorage.getItem(PREF_KEY);
        if(!raw) return;
        const obj = JSON.parse(raw);
        if (obj && typeof obj.selected==='string') selected = obj.selected;
      }catch{}
    };

    // ===== 차트 =====
    let rtTempChart=null, rtBattChart=null;
    const makeLineOpts = (name, yFmt) => ({
      animation:false,
      color:[SKY],
      tooltip:{ trigger:'axis', backgroundColor:'rgba(255,255,255,.9)', borderColor:'#e2e8f0',
        textStyle:{color:'#1f2937'}, axisPointer:{type:'line', lineStyle:{color:SKY}} },
      grid:{top:10,right:10,bottom:30,left:50},
      xAxis:{ type:'time', axisLine:{lineStyle:{color:'#e2e8f0'}}, axisLabel:{color:'#64748b',fontSize:10} },
      yAxis:{ type:'value', axisLine:{show:false}, axisLabel:{color:'#64748b',fontSize:10,formatter:yFmt},
              splitLine:{lineStyle:{color:'#f1f5f9'}} },
      series:[{ name, type:'line', smooth:true, symbol:'none', lineStyle:{width:3,color:SKY},
        areaStyle:{ color:new echarts.graphic.LinearGradient(0,0,0,1,[{offset:0,color:SKY_AREA_TOP},{offset:1,color:SKY_AREA_BOTTOM}]) },
        data:[] }]
    });
    function initCharts(){
      rtTempChart=echarts.init(document.getElementById('rt-temp-chart'));
      rtBattChart=echarts.init(document.getElementById('rt-batt-chart'));
      rtTempChart.setOption(makeLineOpts('온도(℃)', v=>`${v}`));
      rtBattChart.setOption(makeLineOpts('배터리(V)', v=>`${v}`));
      addEventListener('resize', ()=>{ rtTempChart.resize(); rtBattChart.resize(); });
    }
    function pruneSeriesInPlace(obj, now=Date.now()){
      const cutoff = now - WINDOW_MS;
      while (obj.temp.length && obj.temp[0][0] < cutoff) obj.temp.shift();
      while (obj.batt.length && obj.batt[0][0] < cutoff) obj.batt.shift();
    }
    function updateChartsFor(id){
      if (!rtTempChart || !rtBattChart) return;
      const now = Date.now();
      const s = series.get(id) || { temp:[], batt:[], seenTs:new Set() };
      pruneSeriesInPlace(s, now);
      const xwin = { min: now - WINDOW_MS, max: now };
      rtTempChart.setOption({ xAxis:xwin, series:[{data:s.temp}] });
      rtBattChart.setOption({ xAxis:xwin, series:[{data:s.batt}] });
    }

    // ===== 렌더링 =====
    function stateOfTemp(t, tagId){
      const x = Number(t);
      if (!Number.isFinite(x)) return '—';
      if (x < ABS_MIN || x > ABS_MAX) return '이상';
      const { low, high } = getTempThresholdFor(tagId);
      if (x > high) return '높음';
      if (x < low)  return '낮음';
      return '정상';
    }

    function stateOfBatt(v, tagId){
      const st = stateOfBattByPct(v, tagId ?? selected);
      return st.label; // '정상' | '충전 필요' | '—'
    }

    function setErrorBadge(code){
      if (!$errorState) return;
      const n = Number(code);
      let label = '—';
      let cls = 'bg-gray-100 text-gray-700';
      if (Number.isFinite(n)) {
        if (n === 0) { label = '정상'; cls = 'bg-green-100 text-green-700'; }
        else if (n === 1) { label = '경고'; cls = 'bg-amber-100 text-amber-700'; }
        else if (n === 2) { label = '에러'; cls = 'bg-red-100 text-red-700'; }
        else { label = String(n); cls = 'bg-gray-100 text-gray-700'; }
      }
      $errorState.className = 'inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium ' + cls;
      $errorState.textContent = label;
    }

    function renderList(){
      $list.innerHTML = '';
      const ids = (__ALLOWED_TAG_IDS.length ? __ALLOWED_TAG_IDS : knownIds).slice();
      $count.textContent = ids.length ? `${ids.length}대` : '';

      ids.forEach(idRaw=>{
        const id = (idRaw == null ? '' : String(idRaw)).trim().toUpperCase();
        const d = devices.get(id) || {};

        const btn = document.createElement('button');
        btn.className =
          'w-full text-left px-3 py-2 rounded-lg border border-gray-200 hover:bg-gray-50 ' +
          (selected===id ? 'bg-blue-50 border-blue-200' : '');

        const idLabel = macPretty(id) || '(ID 없음)';
        btn.innerHTML = `
          <div class="flex items-center justify-between">
            <span class="font-medium mono text-gray-800">${idLabel}</span>
            <span class="text-xs text-gray-500">${d.ts? new Intl.DateTimeFormat('ko-KR',{timeZone:'Asia/Seoul',hour12:false,year:'2-digit',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit'}).format(d.ts) : ''}</span>
          </div>
          <div class="text-xs text-gray-600 mt-0.5">
            ${Number.isFinite(d.lat)&&Number.isFinite(d.lng)? `${d.lat.toFixed(5)}, ${d.lng.toFixed(5)}` : '위치 —'}
          </div>`;
        btn.onclick = ()=> select(id);
        $list.appendChild(btn);
      });

      window.updateTicker && window.updateTicker();
    }

    function renderDetail(id){
      const d = devices.get(id);
      if(!d){
        $tempLabel.textContent='온도 데이터 : —'; $tempState.textContent='—';
        $battLabel.textContent='배터리 : —'; $battState.textContent='—';
        $location.textContent='—'; $lastSeen.textContent='—';
        $errorCode.textContent='—'; $sendType.textContent='—';
        setErrorBadge(null);
        $openMap.disabled=true; return;
      }
      $tempLabel.textContent = `온도 데이터 : ${d.temperature ?? '—'}°C`;
      $tempState.textContent = stateOfTemp(d.temperature, id);

      const st = stateOfBattByPct(d.battery_voltage, id);
      const vV = (d.battery_voltage!=null) ? (d.battery_voltage>20 ? d.battery_voltage/1000 : d.battery_voltage) : null;
      $battLabel.textContent = `배터리 : ${vV!=null ? vV.toFixed(2)+' V' : '—'}${st.pct!=null ? ` (${st.pct}%)` : ''}`;
      $battState.textContent = st.label;

      if (Number.isFinite(d.lat) && Number.isFinite(d.lng)) { $location.textContent=`${d.lat.toFixed(6)}, ${d.lng.toFixed(6)}`; $openMap.disabled=false; }
      else { $location.textContent='—'; $openMap.disabled=true; }
      $lastSeen.textContent = d.ts ? new Intl.DateTimeFormat('ko-KR',{timeZone:'Asia/Seoul',hour12:false,year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit'}).format(d.ts) : '—';

      $errorCode.textContent = (d.error_code ?? '—');
      $sendType.textContent  = (d.send_type  ?? '—');
      setErrorBadge(d.error_code);

      updateChartsFor(id);
    }

    // ===== 선 끊기 보정 =====
    function binInsertIndex(arr, ts){
      let lo = 0, hi = arr.length;
      while (lo < hi){
        const mid = (lo + hi) >> 1;
        if (arr[mid][0] <= ts) lo = mid + 1; else hi = mid;
      }
      return lo;
    }
    function appendSortedWithGap(arr, ts, val){
      if (arr.length){
        const lastTs = arr[arr.length-1][0];
        if (ts - lastTs > GAP_MS){
          arr.push([lastTs + 1, null]);
        }
      }
      const i = binInsertIndex(arr, ts);
      if (i > 0 && arr[i-1][0] === ts){ arr[i-1][1] = val; return; }
      if (i < arr.length && arr[i][0] === ts){ arr[i][1] = val; return; }
      arr.splice(i, 0, [ts, val]);
    }

    // ===== 시계열 추가 =====
    function pushSample(id, ts, temp, battRaw){
      let obj = series.get(id);
      if (!obj){
        obj = { temp: [], batt: [], seenTs: new Set() };
        series.set(id, obj);
      }
      if (obj.seenTs.has(ts)) return;
      obj.seenTs.add(ts);

      if (temp != null && Number.isFinite(Number(temp))){
        appendSortedWithGap(obj.temp, ts, Number(temp));
      }
      if (battRaw != null && Number.isFinite(Number(battRaw))){
        let v = Number(battRaw);
        if (v > 20) v = v / 1000;
        appendSortedWithGap(obj.batt, ts, v);
      }

      pruneSeriesInPlace(obj, Date.now());
      const MAX_POINTS = 300;
      if (obj.temp.length > MAX_POINTS) obj.temp.splice(0, obj.temp.length - MAX_POINTS);
      if (obj.batt.length > MAX_POINTS) obj.batt.splice(0, obj.batt.length - MAX_POINTS);
    }

    // ===== REST: 디바이스 목록 =====
    async function loadDeviceList(){
      if (!__ALLOWED_READY) await refreshAllowedIds();

      knownIds = __ALLOWED_TAG_IDS.slice();
      window.knownIds = knownIds; // ★ 전역 동기화
      for (const id of knownIds){ if (!devices.has(id)) devices.set(id, {}); }
      renderList();

      // (옵션) REST 목록을 허용 리스트와 교집합으로 합치기
      try{
        const res = await fetch(`${API_BASE}/${COLLECTION_PATH}`, {mode:'cors'});
        const txt = await res.text();
        if (!res.ok) return;
        const data = JSON.parse(txt);
        const list = Array.isArray(data?.devices) ? data.devices : (Array.isArray(data) ? data : []);
        const extra = list.map(macHex12).filter(id => __ALLOWED_TAG_IDS.includes(id));
        const union = [...new Set([...knownIds, ...extra])].sort();
        const changed = union.length !== knownIds.length || union.some((v,i)=>v!==knownIds[i]);
        if (changed){
          knownIds = union;
          window.knownIds = knownIds; // ★ 전역 동기화
          for (const id of extra){ if (!devices.has(id)) devices.set(id, {}); }
          renderList();
        }
      }catch(e){
        console.error('[devices] failed:', e);
      }
    }

    // ===== 선택 & 백필 =====
    async function select(id){
      id = macHex12(id);
      if (__ALLOWED_TAG_IDS.length && !__ALLOWED_TAG_IDS.includes(id)) return;
      selected = id; saveSelected();
      series.set(id, { temp:[], batt:[], seenTs:new Set() });
      if (!devices.has(id)) devices.set(id, {});
      renderList();
      renderDetail(id);
      await backfillSelected(5,true);
      renderDetail(id);
      window.updateTicker && window.updateTicker();
    }

    async function backfillSelected(minutes = 5, stickToNow = true){
      if (!selected) return;
      const id = macHex12(selected);
      if (__ALLOWED_TAG_IDS.length && !__ALLOWED_TAG_IDS.includes(id)) return;

      const now   = Date.now();
      const since = now - minutes*60*1000;

      // 최근 N분만 ASC로 받아서 시계열에 그대로 push
      const url = `${API_BASE}/${COLLECTION_PATH}?tag_address=${encodeURIComponent(macPretty(id))}&days=1&order=asc&limit=10000`;
      try{
        const res = await fetch(url, {mode:'cors'});
        const txt = await res.text();
        if (!res.ok) { console.error('[backfill] HTTP', res.status, txt); return; }
        let data; try{ data = JSON.parse(txt); }catch{ console.error('[backfill] invalid json'); return; }
        const rows = Array.isArray(data) ? data : (data.items || []);

        const items = rows.map(r=>{
          const ts = pickTs(r);
          return {
            ts,
            temp: toNum(r.temperature ?? r.temp),
            batt: toNum(r.battery_voltage ?? r.battery),
            lat:  toNum(r.latitude),
            lng:  toNum(r.longitude ?? r.longtitude),
            error_code: r.error_code ?? null,
            send_type:  r.send_type  ?? null
          };
        }).filter(x=> Number.isFinite(x.ts) && x.ts>=since && x.ts<=now)
          .sort((a,b)=>a.ts-b.ts);

        // 과거 N분 시계열 채움
        for (const it of items) pushSample(selected, it.ts, it.temp, it.batt);

        // 디바이스 카드 최신값 동기화
        if (items.length){
          const last = items[items.length-1];
          const prev = devices.get(selected) || {};
          devices.set(selected, {
            ...prev,
            temperature: last.temp ?? prev.temperature,
            battery_voltage: last.batt ?? prev.battery_voltage,
            lat: last.lat ?? prev.lat,
            lng: last.lng ?? prev.lng,
            error_code: last.error_code ?? prev.error_code,
            send_type: last.send_type ?? prev.send_type,
            ts: last.ts
          });
        }

        // ★ 클릭 직후, 지금 시각까지 라인을 "즉시" 이어주기
        if (stickToNow){
          const d = devices.get(selected); // snapshotLatestForAllowed/WS가 담아둔 최신 값
          if (d && Number.isFinite(d.ts)){
            // 백필의 마지막 포인트 시각과 차이가 크면 한 점 더 찍어 이어붙임
            const s = series.get(selected) || { temp:[], batt:[], seenTs:new Set() };
            const lastTs = Math.max(
              s.temp.length  ? s.temp[s.temp.length-1][0]  : -Infinity,
              s.batt.length  ? s.batt[s.batt.length-1][0]  : -Infinity
            );
            if (!Number.isFinite(lastTs) || (d.ts - lastTs) > 2000){
              let vTemp = d.temperature;
              let vBatt = d.battery_voltage;
              if (vBatt != null && vBatt > 20) vBatt = vBatt/1000; // mV→V 보정
              pushSample(selected, d.ts, vTemp, vBatt);
            }
          }
        }

        renderList();
        updateChartsFor(selected); // x축은 WINDOW_MS(=5분)라 지금 창으로 고정
        window.updateTicker && window.updateTicker();
      }catch(e){
        console.error('[backfill] failed:', e);
      }
    }


    // ===== 허용 태그들의 최신 1건 스냅샷 =====
    async function snapshotLatestForAllowed(){
      const ids = (__ALLOWED_TAG_IDS.length ? __ALLOWED_TAG_IDS : knownIds).slice();
      if (!ids.length) return;

      const jobs = ids.map(async (id)=>{
        const url = `${API_BASE}/${COLLECTION_PATH}?tag_address=${encodeURIComponent(macPretty(id))}&days=1&order=desc&limit=1`;
        try{
          const res = await fetch(url, { mode:'cors' });
          const data = await res.json().catch(()=>[]);
          const rows = Array.isArray(data) ? data : (data.items || []);
          const r = rows[0];
          if (!r) return;

          const ts   = pickTs(r);
          const temp = toNum(r.temperature ?? r.temp);
          const batt = toNum(r.battery_voltage ?? r.battery);
          const lat  = toNum(r.latitude);
          const lng  = toNum(r.longitude ?? r.longtitude);

          const prev = devices.get(id) || {};
          devices.set(id, {
            ...prev,
            temperature: temp ?? prev.temperature,
            battery_voltage: batt ?? prev.battery_voltage,
            lat: lat ?? prev.lat,
            lng: lng ?? prev.lng,
            error_code: r.error_code ?? prev.error_code ?? null,
            send_type:  r.send_type  ?? prev.send_type  ?? null,
            ts
          });

          if (ts != null) pushSample(id, ts, temp, batt); // 차트도 한 포인트 미리
        }catch(e){
          console.warn('[snapshot] fail', id, e);
        }
      });

      await Promise.all(jobs);
      renderList();
      if (selected) renderDetail(selected);
      updateTicker();
    }

    // ===== WebSocket =====
    function handleMessage(raw){
      try{
        const msg = JSON.parse(raw);
        const idRaw = msg.tag_address || msg.device_id || msg.id;
        if (!idRaw) return;
        const id = macHex12(idRaw);
        if (__ALLOWED_TAG_IDS.length && !__ALLOWED_TAG_IDS.includes(id)) return;

        if (!knownIds.includes(id)){
          knownIds.push(id);
          knownIds.sort();
          window.knownIds = knownIds; // ★ 전역 동기화
        }

        const temp = toNum(msg.temperature);
        const batt = (msg.battery_voltage!=null) ? toNum(msg.battery_voltage)
                    : (msg.battery!=null ? toNum(msg.battery) : null);
        const lat  = toNum(msg.latitude);
        const lng  = toNum(msg.longitude);
        const tsRaw = toNum(msg.timestamp ?? msg.time ?? msg.ts ?? msg.timestamp_epoch) ?? Date.now();
        const ts = tsRaw < 1e12 ? tsRaw*1000 : tsRaw;

        const next = devices.get(id) || {};
        devices.set(id, {
          ...next,
          temperature: temp ?? next.temperature,
          battery_voltage: batt ?? next.battery_voltage,
          lat: lat ?? next.lat,
          lng: lng ?? next.lng,
          error_code: (msg.error_code ?? next.error_code),
          send_type:  (msg.send_type  ?? next.send_type),
          ts,
          lastWsTs: Date.now(),
        });

        pushSample(id, ts, temp, batt);

        renderList();
        if (selected==null && knownIds.length===1){ selected = id; saveSelected(); }
        if (selected===id){ renderDetail(id); }

        window.updateTicker && window.updateTicker();
      }catch(e){
        console.error('WS parse error:', e, raw);
      }
    }

    let ws, retry=0;
    function connectWS(){
      ws = new WebSocket(WS_URL);
      ws.onopen = ()=>{ retry=0; };
      ws.onmessage = (ev)=> handleMessage(ev.data);
      ws.onclose = ()=> setTimeout(connectWS, Math.min(1000*(++retry), 10000));
      ws.onerror = ()=> ws.close();
    }

    // ===== GPS 페이지 열기 =====
    function openGpsPage(){
      if(!selected || !devices.has(selected)) return;
      const d = devices.get(selected);
      if(!Number.isFinite(d.lat)||!Number.isFinite(d.lng)){ alert('선택된 디바이스의 위치 데이터가 없습니다.'); return; }
      const p = new URLSearchParams();
      p.set('devices', selected);
      p.set('center', `${d.lat},${d.lng}`);
      p.set('lat', d.lat); p.set('lng', d.lng); p.set('zoom', 16);
      if (Number.isFinite(d.ts)) p.set('ts', d.ts);
      if (d.temperature!=null) p.set('temp', d.temperature);
      if (d.battery_voltage!=null) p.set('battery', d.battery_voltage);
      window.open(`gps.html?${p.toString()}`, '_blank');
    }

    // ===== 시작 =====
    (async function(){
      await waitAuthReady();

      document.getElementById('open-map')?.addEventListener('click', openGpsPage);
      (function waitSJUI(){
        if (!window.SJUI) return setTimeout(waitSJUI, 40);
        window.updateTicker && window.updateTicker(); // ✅ 로테이터 준비 직후 현재 상태 반영
      })();

      initCharts();

      restoreSelected();
      await refreshAllowedIds();
      try {
        await snapshotLatestForAllowed();
      } catch (e) {
        console.error('[snapshotLatestForAllowed] failed:', e);
      }

      if (!selected || !__ALLOWED_TAG_IDS.includes(selected)) {
        selected = __ALLOWED_TAG_IDS[0] || null;
        saveSelected();
      }

      await loadDeviceList();

      if (selected && knownIds.includes(selected)){
        if (!devices.has(selected)) devices.set(selected, { ts: null });
        renderList();
        await backfillSelected(5,true);
        renderDetail(selected);
      } else {
        if (selected && !knownIds.includes(selected)) { selected = null; saveSelected(); renderList(); }
      }

      window.updateTicker && window.updateTicker();
      connectWS();
      setInterval(refreshAllowedIds, 10_000);
    })();
  </script>
</body>
</html>
